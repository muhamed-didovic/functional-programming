{"version":3,"sources":["../../../modules/examples/either.js"],"names":["Right","chain","f","x","ap","other","map","traverse","of","fold","g","inspect","Left","fromNullable","tryCatch","e","module","exports"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAMA,QAAQ,SAARA,KAAQ;AAAA,SACX;AACCC,WAAO;AAAA,aAAKC,EAAEC,CAAF,CAAL;AAAA,KADR;AAECC,QAAI;AAAA,aAASC,MAAMC,GAAN,CAAUH,CAAV,CAAT;AAAA,KAFL;AAGCI,cAAU,kBAACC,EAAD,EAAKN,CAAL;AAAA,aAAWA,EAAEC,CAAF,EAAKG,GAAL,CAASN,KAAT,CAAX;AAAA,KAHX;AAICM,SAAK;AAAA,aAAKN,MAAME,EAAEC,CAAF,CAAN,CAAL;AAAA,KAJN;AAKCM,UAAM,cAACP,CAAD,EAAIQ,CAAJ;AAAA,aAAUA,EAAEP,CAAF,CAAV;AAAA,KALP;AAMCQ,aAAS;AAAA,wBAAeR,CAAf;AAAA;AANV,GADW;AAAA,CAAd;;AAUA,IAAMS,OAAO,SAAPA,IAAO;AAAA,SACV;AACCX,WAAO;AAAA,aAAKW,KAAKT,CAAL,CAAL;AAAA,KADR;AAECC,QAAI;AAAA,aAASQ,KAAKT,CAAL,CAAT;AAAA,KAFL;AAGCI,cAAU,kBAACC,EAAD,EAAKN,CAAL;AAAA,aAAWM,GAAGI,KAAKT,CAAL,CAAH,CAAX;AAAA,KAHX;AAICG,SAAK;AAAA,aAAKM,KAAKT,CAAL,CAAL;AAAA,KAJN;AAKCM,UAAM,cAACP,CAAD,EAAIQ,CAAJ;AAAA,aAAUR,EAAEC,CAAF,CAAV;AAAA,KALP;AAMCQ,aAAS;AAAA,uBAAcR,CAAd;AAAA;AANV,GADU;AAAA,CAAb;;AAUA,IAAMU,eAAe,SAAfA,YAAe;AAAA,SAAKV,KAAK,IAAL,GAAYH,MAAMG,CAAN,CAAZ,GAAuBS,KAAK,IAAL,CAA5B;AAAA,CAArB;;AAEA,IAAME,WAAW,SAAXA,QAAW,IAAK;AACpB,MAAI;AACF,WAAOd,MAAME,GAAN,CAAP;AACD,GAFD,CAEE,OAAMa,CAAN,EAAS;AACT,WAAOH,KAAKG,CAAL,CAAP;AACD;AACF,CAND;;AASAC,OAAOC,OAAP,GAAiB;AACfjB,cADe;AAEfY,YAFe;AAGfC,4BAHe;AAIfC;AAJe,CAAjB","file":"either.js","sourcesContent":["// const Right = x =>\n//   ({\n//     chain: f => f(x),\n//     map: f => Right(f(x)),\n//     fold: (f, g) => g(x),\n//     inspect: () => `Right(${x})`\n//   })\n//\n// const Left = x =>\n//   ({\n//     //chain is used when there is Either inside of map method\n//     chain: f => Left(x), // .chain expects you to run a function and return another one\n//     map: f => Left(x),\n//     fold: (f, g) => f(x), // .fold is going to capture the idea of removing a value from its context -- taking it out of the box, whether it's a right or a left or a box itself.\n//     inspect: () => `Left(${x})`\n//   })\n\nconst Right = x =>\n  ({\n    chain: f => f(x),\n    ap: other => other.map(x),\n    traverse: (of, f) => f(x).map(Right),\n    map: f => Right(f(x)),\n    fold: (f, g) => g(x),\n    inspect: () => `Right(${x})`\n  })\n\nconst Left = x =>\n  ({\n    chain: f => Left(x),\n    ap: other => Left(x),\n    traverse: (of, f) => of(Left(x)),\n    map: f => Left(x),\n    fold: (f, g) => f(x),\n    inspect: () => `Left(${x})`\n  })\n\nconst fromNullable = x => x != null ? Right(x) : Left(null)\n\nconst tryCatch = f => {\n  try {\n    return Right(f())\n  } catch(e) {\n    return Left(e)\n  }\n}\n\n\nmodule.exports = {\n  Right,\n  Left,\n  fromNullable,\n  tryCatch\n}\n"]}