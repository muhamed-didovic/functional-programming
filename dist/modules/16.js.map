{"version":3,"sources":["../../modules/16.js"],"names":["Box","require","join","m","chain","x","res1","of","res2","map","console","log"],"mappings":";;AAAA;;AAEA;AACA;;AAEA,IAAMA,MAAMC,QAAQ,gBAAR,CAAZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA,IAAMC,OAAO,SAAPA,IAAO;AAAA,SACXC,EAAEC,KAAF,CAAQ;AAAA,WAAKC,CAAL;AAAA,GAAR,CADW;AAAA,CAAb,C,CACkB;;AAElB;;AAEA;AACA;AACA;;AAEA;AACA,IAAMF,IAAIH,IAAI,QAAJ,CAAV;AACA,IAAMM,OAAOJ,KAAKF,IAAIO,EAAJ,CAAOJ,CAAP,CAAL,CAAb;AACA,IAAMK,OAAON,KAAKC,EAAEM,GAAF,CAAMT,IAAIO,EAAV,CAAL,CAAb;;AAEAG,QAAQC,GAAR,CAAYL,IAAZ,EAAkBE,IAAlB;;AAGA;AACA;AACA;;AAEA","file":"16.js","sourcesContent":["//MONADS(has 'of' and 'chain' method)\n\n//We discover, we've been using monads! We look a little further into the chain method and see\n// laws that ensure the monadic structure works correctly.\n\nconst Box = require('./examples/box')\n\n//Box, Either, Task, List\n// F.of, chain (flatMap, bind, >>=)\n\n// httpGet('/user')\n//   .chain(user =>\n//     httpGet(`/comments/${user.id}`)\n//       .chain(comments =>\n//         updateDOM(user, comments))) // Task(Task(Task(DOM)))\n\n\nconst join = m =>\n  m.chain(x => x) // Box(Box(x)) it would return -> Box(x)\n\n//1. rule: join(m.map(join) == join(join(m)) //law of associativity\n\n// const m = Box(Box(Box(3)))\n// const res1 = join(m.map(join))\n// const res2 = join(join(m))\n\n//2. rule: join(Box.of(m)) == join(m.map(Box.of))\nconst m = Box('wonder')\nconst res1 = join(Box.of(m))\nconst res2 = join(m.map(Box.of))\n\nconsole.log(res1, res2)\n\n\n//map is definably by chain\n// m.chain(x => f(x))\n// m.chain(x => Box.of(f(x)))\n\n//monad -> implicitiv functor, applicitive functor"]}