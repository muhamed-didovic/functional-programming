{"version":3,"sources":["../../modules/4.js"],"names":["fs","readFileSync","name","JSON","stringify","port","Right","chain","f","x","map","fold","g","inspect","Left","fromNullable","tryCatch","e","getPort","parse","c","result","console","log"],"mappings":";;AAAA;;;;;;;AAOA;AACA;AACA,IAAMA,KAAK;AACTC,gBAAc,4BAAQ;AACpB,QAAGC,SAAS,aAAZ,EAA2B;AACzB,aAAOC,KAAKC,SAAL,CAAe,EAACC,MAAM,IAAP,EAAf,CAAP;AACD,KAFD,MAEO;AACL,YAAM,eAAN;AACD;AACF;AAPQ,CAAX;;AAUA,IAAMC,QAAQ,SAARA,KAAQ;AAAA,SACX;AACCC,WAAO;AAAA,aAAKC,EAAEC,CAAF,CAAL;AAAA,KADR;AAECC,SAAK;AAAA,aAAKJ,MAAME,EAAEC,CAAF,CAAN,CAAL;AAAA,KAFN;AAGCE,UAAM,cAACH,CAAD,EAAII,CAAJ;AAAA,aAAUA,EAAEH,CAAF,CAAV;AAAA,KAHP;AAICI,aAAS;AAAA,wBAAeJ,CAAf;AAAA;AAJV,GADW;AAAA,CAAd;;AAQA,IAAMK,OAAO,SAAPA,IAAO;AAAA,SACV;AACC;AACAP,WAAO;AAAA,aAAKO,KAAKL,CAAL,CAAL;AAAA,KAFR,EAEsB;AACrBC,SAAK;AAAA,aAAKI,KAAKL,CAAL,CAAL;AAAA,KAHN;AAICE,UAAM,cAACH,CAAD,EAAII,CAAJ;AAAA,aAAUJ,EAAEC,CAAF,CAAV;AAAA,KAJP,EAIuB;AACtBI,aAAS;AAAA,uBAAcJ,CAAd;AAAA;AALV,GADU;AAAA,CAAb;;AASA,IAAMM,eAAe,SAAfA,YAAe;AAAA,SACnBN,KAAK,IAAL,GAAYH,MAAMG,CAAN,CAAZ,GAAuBK,KAAK,IAAL,CADJ;AAAA,CAArB;;AAGA,IAAME,WAAW,SAAXA,QAAW,IAAK;AACpB,MAAI;AACF,WAAOV,MAAME,GAAN,CAAP;AACD,GAFD,CAEE,OAAOS,CAAP,EAAU;AACV,WAAOH,KAAKG,CAAL,CAAP;AACD;AACF,CAND;;AAQA,IAAMC,UAAU,SAAVA,OAAU;AAAA,SACdF,SAAS;AAAA,WAAMhB,GAAGC,YAAH,CAAgB,aAAhB,CAAN;AAAA,GAAT,EACGM,KADH,CACS;AAAA,WAAKS,SAAS;AAAA,aAAMb,KAAKgB,KAAL,CAAWC,CAAX,CAAN;AAAA,KAAT,CAAL;AAAA,GADT,EAEGT,IAFH,CAEQ;AAAA,WAAK,IAAL;AAAA,GAFR,EAEmB;AAAA,WAAKS,EAAEf,IAAP;AAAA,GAFnB,CADc;AAAA,CAAhB;;AAKA,IAAMgB,SAASH,SAAf;;AAEAI,QAAQC,GAAR,CAAYF,MAAZ","file":"4.js","sourcesContent":["/*\nUse chain for composable error handling with nested Eithers\n\nWe refactor a function that uses try/catch to a single composed expression using Either.\nWe then introduce the chain function to deal with nested Eithers resulting from two try/catch calls.\n*/\n\n// SETUP: fake fs\n//==========\nconst fs = {\n  readFileSync: name => {\n    if(name === 'config.json') {\n      return JSON.stringify({port: 8888})\n    } else {\n      throw('missing file!')\n    }\n  }\n}\n\nconst Right = x =>\n  ({\n    chain: f => f(x),\n    map: f => Right(f(x)),\n    fold: (f, g) => g(x),\n    inspect: () => `Right(${x})`\n  })\n\nconst Left = x =>\n  ({\n    //chain is used when there is Either inside of map method\n    chain: f => Left(x), // .chain expects you to run a function and return another one\n    map: f => Left(x),\n    fold: (f, g) => f(x), // .fold is going to capture the idea of removing a value from its context -- taking it out of the box, whether it's a right or a left or a box itself.\n    inspect: () => `Left(${x})`\n  })\n\nconst fromNullable = x =>\n  x != null ? Right(x) : Left(null)\n\nconst tryCatch = f => {\n  try {\n    return Right(f())\n  } catch (e) {\n    return Left(e)\n  }\n}\n\nconst getPort = () =>\n  tryCatch(() => fs.readFileSync('config.json'))\n    .chain(c => tryCatch(() => JSON.parse(c)))\n    .fold(e => 3000, c => c.port)\n\nconst result = getPort()\n\nconsole.log(result)\n"]}