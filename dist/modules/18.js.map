{"version":3,"sources":["../../modules/18.js"],"names":["Box","chain","f","x","ap","other","map","fold","inspect","add","y","liftA2","fx","fy","liftA3","fz","res1","res2","console","log"],"mappings":";;AAAA;;AAEA;AACA;AACA;;;AAGA,IAAMA,MAAM,SAANA,GAAM;AAAA,SACT;AACCC,WAAO;AAAA,aAAKC,EAAEC,CAAF,CAAL;AAAA,KADR;AAECC,QAAI;AAAA,aAASC,MAAMC,GAAN,CAAUH,CAAV,CAAT;AAAA,KAFL;AAGCG,SAAK;AAAA,aAAKN,IAAIE,EAAEC,CAAF,CAAJ,CAAL;AAAA,KAHN;AAICI,UAAM;AAAA,aAAKL,EAAEC,CAAF,CAAL;AAAA,KAJP;AAKCK,aAAS;AAAA,sBAAaL,CAAb;AAAA;AALV,GADS;AAAA,CAAZ;;AASA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA,IAAMM,MAAM,SAANA,GAAM;AAAA,SAAK;AAAA,WAAKN,IAAIO,CAAT;AAAA,GAAL;AAAA,CAAZ;;AAEA;AACA;AACA,IAAMC,SAAS,SAATA,MAAS,CAACT,CAAD,EAAIU,EAAJ,EAAQC,EAAR;AAAA,SAAeD,GAAGN,GAAH,CAAOJ,CAAP,EAAUE,EAAV,CAAaS,EAAb,CAAf;AAAA,CAAf;;AAEA,IAAMC,SAAS,SAATA,MAAS,CAACZ,CAAD,EAAIU,EAAJ,EAAQC,EAAR,EAAYE,EAAZ;AAAA,SAAmBH,GAAGN,GAAH,CAAOJ,CAAP,EAAUE,EAAV,CAAaS,EAAb,EAAiBT,EAAjB,CAAoBW,EAApB,CAAnB;AAAA,CAAf;;AAEA,IAAMC,OAAOhB,IAAIS,GAAJ,EAASL,EAAT,CAAYJ,IAAI,CAAJ,CAAZ,EAAoBI,EAApB,CAAuBJ,IAAI,CAAJ,CAAvB,CAAb;;AAEA,IAAMiB,OAAON,OAAOF,GAAP,EAAYT,IAAI,CAAJ,CAAZ,EAAoBA,IAAI,CAAJ,CAApB,CAAb;;AAEAkB,QAAQC,GAAR,CAAY,YAAZ,EAA0BH,KAAKR,OAAL,EAA1B;AACAU,QAAQC,GAAR,CAAY,YAAZ,EAA0BF,KAAKT,OAAL,EAA1B","file":"18.js","sourcesContent":["//Applicative Functors for multiple arguments\n\n//Working our way backwards from solution to problem,\n// we define an applicative functor,\n// then use it to apply a function of multiple arguments.\n\n\nconst Box = x =>\n  ({\n    chain: f => f(x),\n    ap: other => other.map(x),\n    map: f => Box(f(x)),\n    fold: f => f(x),\n    inspect: () => `Box(${x})`\n  })\n\n// Box(2) or value 2 will be passed to Box(x => x + 1) to get result  Box(3)\n// const res = Box(x => x + 1).ap(Box(2)) //Box(3)\n\n//const res = Box(x => y => x + y).app(Box(2)) //Box(y => 2 + y) -> Box(y => 2 + y).ap(Box(3))\n\n//it must be in curried form\n//const res = Box(x => y => x + y).app(Box(2)).app(Box(3))\n\n//second way\n//const add = x => y => x + y\n//const res = Box(add).ap(Box(2)).ap(Box(3))\n//if it has 'ap'(applied) method it is called applicative functor\n\n//RULE: Functor(x).map(f) == Functor(f).ap(Functor(x))\n\n//we worked until now with: Box(x).map(f)\n\n\nconst add = x => y => x + y\n\n//fx -> functor with x, fy -> functor with y\n// we could use F(f).ap(fx).ap(fy) but with don't know what is 'f' in F(f)\nconst liftA2 = (f, fx, fy) => fx.map(f).ap(fy)\n\nconst liftA3 = (f, fx, fy, fz) => fx.map(f).ap(fy).ap(fz)\n\nconst res1 = Box(add).ap(Box(2)).ap(Box(4))\n\nconst res2 = liftA2(add, Box(2), Box(4))\n\nconsole.log(\"result 1: \", res1.inspect())\nconsole.log(\"result 2: \", res2.inspect())"]}